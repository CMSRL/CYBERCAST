// %BANNER_BEGIN%
// ---------------------------------------------------------------------
// %COPYRIGHT_BEGIN%
// Copyright (c) (2024) Magic Leap, Inc. All Rights Reserved.
// Use of this file is governed by the Software License Agreement, located here: https://www.magicleap.com/software-license-agreement-ml2
// Terms and conditions applicable to third-party materials accompanying this distribution may also be found in the top-level NOTICE file appearing herein.
// %COPYRIGHT_END%
// ---------------------------------------------------------------------
// %BANNER_END%
using MagicLeap.Android;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;
using static MagicLeapInputs;
using System;
using Esri.ArcGISMapsSDK.Components;
using Esri.GameEngine.Geometry;
using UnityEngine.UIElements.Experimental;



namespace Esri.ArcGISMapsSDK.Samples.Components
{
    public class MapController : MonoBehaviour
    {
        // This was autogenerated and allows developers to create a dynamic
        // instance of an InputActionAsset which includes predefined action maps
        // that correspond to all of the Magic Leap 2's input.

        private MagicLeapInputs.ControllerActions controllerActions;
        public ArcGISTabletopControllerComponent tabletopcomponent;
        private UnityEngine.XR.InputDevice eyeTracking;
        private Vector3 currentGazePosition;
        private float zoomScalar = 1.0f;



        private void Start()
        {

        }
        private void Awake()
        {
        }



        private void Update()
        {



        }



        private void OnDisable()
        {

        }

        public void ZoomMap(InputAction.CallbackContext obj)
        {
            // reading the values from InputActions
            //tabletopcomponent.ZoomMap(0.25f, currentGazePosition);
        }

        private void IsTrackedOnPerformed(InputAction.CallbackContext obj)
        {
            Debug.Log("The Controller Is tracking");
        }

        private void HandleMoveTrackpad(InputAction.CallbackContext obj)
        {
            var trackpadValue = obj.ReadValue<Vector2>();
            var angle = Math.Atan2(trackpadValue.x, trackpadValue.y) * 180 / Math.PI;
            if (angle < 0)
            {
                angle = 180 + (angle + 180);
            }
            (double value1, double value2) newCoordinate = get_point_at_distance(tabletopcomponent.Center.Y, tabletopcomponent.Center.X, .005f, angle);
            Recenter(newCoordinate);

        }

        public void SimpleZoomIn()
        {
            tabletopcomponent.Width = 1.10f * tabletopcomponent.Width;
            if (tabletopcomponent.Shape == MapExtentShapes.Rectangle)
            {
                tabletopcomponent.Height += 1.10f * tabletopcomponent.Height;
            }
        }

        public void SimpleZoomOut()
        {
            tabletopcomponent.Width = 0.90f * tabletopcomponent.Width;
            if (tabletopcomponent.Shape == MapExtentShapes.Rectangle)
            {
                tabletopcomponent.Height += 0.90f * tabletopcomponent.Height;
            }
        }

        public void ZoomMap(float zoom, Vector3 screenPoint)
        {
            if (zoom == 0)
            {
                return;
            }

            Vector3 outPoint;
            var zoomRay = Camera.main.ScreenPointToRay(screenPoint);

            if (tabletopcomponent.Raycast(zoomRay, out outPoint))
            {
                // More zoom means smaller extent
                tabletopcomponent.Width -= zoom * tabletopcomponent.Width / zoomScalar;
                if (tabletopcomponent.Shape == MapExtentShapes.Rectangle)
                {
                    tabletopcomponent.Height -= zoom * tabletopcomponent.Height / zoomScalar;
                }
            }
        }

        public void Recenter((double value1, double value2) newCoordinate)
        {
            
            //Debug.Log(newCoordinate);
            var oldCenter = tabletopcomponent.Center;
            try
            {
                tabletopcomponent.Center = new GameEngine.Geometry.ArcGISPoint(newCoordinate.value2, newCoordinate.value1, oldCenter.Z, ArcGISSpatialReference.WGS84());
            }
            catch
            {
                tabletopcomponent.Center = oldCenter;
            }


        }

        //https://stackoverflow.com/questions/7222382/get-lat-long-given-current-point-distance-and-bearing
        private (double value1, double value2) get_point_at_distance(double lat1, double lon1, float d, double bearing, int R = 6371)
        {
            /*
            lat: initial latitude, in degrees
            lon: initial longitude, in degrees
            d: target distance from initial
            bearing: (true) heading in degrees
            R: optional radius of sphere, defaults to mean radius of earth

            Returns new lat/lon coordinate {d}km from initial, in degrees
            */
            lat1 = DegreesToRadians(lat1);
            lon1 = DegreesToRadians(lon1);
            double a = DegreesToRadians(bearing);
            double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(d / R) + Math.Cos(lat1) * Math.Sin(d / R) * Math.Cos(a));
            double lon2 = lon1 + Math.Atan2(
                Math.Sin(a) * Math.Sin(d / R) * Math.Cos(lat1),
                Math.Cos(d / R) - Math.Sin(lat1) * Math.Sin(lat2)
            );

            (double value1, double value2) outTuple = (ConvertRadiansToDegrees(lat2), ConvertRadiansToDegrees(lon2));
            return outTuple;
        }

        static double DegreesToRadians(double degrees)
        {
            return degrees * (Math.PI / 180);
        }

        public static double ConvertRadiansToDegrees(double radians)
        {
            double degrees = (180 / Math.PI) * radians;
            return degrees;
        }
    }
    }
